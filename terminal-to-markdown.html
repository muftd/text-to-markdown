<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ç»ˆç«¯è½¬ Markdown è½¬æ¢å™¨</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600&family=Space+Grotesk:wght@700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary-green: #00d95f;
      --dark-green: #0a2a1a;
      --bg-primary: #0a0f14;
      --bg-secondary: #111820;
      --border-color: #1a2a2a;
      --text-primary: #e0e6f0;
      --text-secondary: #8a9ab0;
      --accent-success: #00d95f;
      --accent-error: #ff4757;
      --glow-intensity: 0.4;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html {
      scroll-behavior: smooth;
    }

    body {
      font-family: 'IBM Plex Mono', monospace;
      background: linear-gradient(135deg, var(--bg-primary) 0%, #0d1a24 50%, var(--bg-primary) 100%);
      background-attachment: fixed;
      color: var(--text-primary);
      line-height: 1.6;
      padding: 2rem;
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
    }

    /* ç½‘æ ¼èƒŒæ™¯çº¹ç† */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image:
        linear-gradient(0deg, transparent 24%, rgba(0, 217, 95, 0.05) 25%, rgba(0, 217, 95, 0.05) 26%, transparent 27%, transparent 74%, rgba(0, 217, 95, 0.05) 75%, rgba(0, 217, 95, 0.05) 76%, transparent 77%, transparent),
        linear-gradient(90deg, transparent 24%, rgba(0, 217, 95, 0.05) 25%, rgba(0, 217, 95, 0.05) 26%, transparent 27%, transparent 74%, rgba(0, 217, 95, 0.05) 75%, rgba(0, 217, 95, 0.05) 76%, transparent 77%, transparent);
      background-size: 60px 60px;
      pointer-events: none;
      z-index: 0;
    }

    .container {
      max-width: 1100px;
      margin: 0 auto;
      position: relative;
      z-index: 1;
    }

    h1 {
      font-family: 'Space Grotesk', sans-serif;
      font-size: 2.2rem;
      margin-bottom: 0.5rem;
      background: linear-gradient(135deg, var(--primary-green) 0%, #00ff7f 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      font-weight: 700;
      letter-spacing: 1px;
      text-shadow: 0 0 20px rgba(0, 217, 95, 0.3);
      animation: fadeInDown 0.8s ease-out;
    }

    .subtitle {
      color: var(--text-secondary);
      font-size: 0.95rem;
      margin-bottom: 2rem;
      font-style: italic;
      animation: fadeInUp 0.8s ease-out 0.1s both;
    }

    .section {
      margin-bottom: 2.5rem;
      background: linear-gradient(135deg, var(--bg-secondary) 0%, rgba(26, 42, 42, 0.3) 100%);
      border: 1px solid var(--border-color);
      padding: 1.8rem;
      border-radius: 12px;
      backdrop-filter: blur(10px);
      position: relative;
      overflow: hidden;
      transition: all 0.4s cubic-bezier(0.23, 1, 0.320, 1);
      animation: slideInUp 0.6s ease-out;
      animation-fill-mode: both;
    }

    .section:nth-child(1) { animation-delay: 0.1s; }
    .section:nth-child(2) { animation-delay: 0.2s; }
    .section:nth-child(3) { animation-delay: 0.3s; }

    .section::before {
      content: '';
      position: absolute;
      top: -50%;
      right: -50%;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(0, 217, 95, 0.1) 0%, transparent 70%);
      pointer-events: none;
    }

    .section:hover {
      border-color: var(--primary-green);
      box-shadow: 0 0 20px rgba(0, 217, 95, 0.15), inset 0 0 20px rgba(0, 217, 95, 0.05);
      transform: translateY(-4px);
    }

    .section-title {
      font-weight: 600;
      margin-bottom: 1rem;
      color: var(--primary-green);
      text-transform: uppercase;
      font-size: 0.85rem;
      letter-spacing: 2px;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .section-title::before {
      content: '';
      width: 8px;
      height: 8px;
      background: var(--primary-green);
      border-radius: 50%;
      animation: pulse 2s ease-in-out infinite;
    }

    textarea {
      width: 100%;
      font-family: 'IBM Plex Mono', monospace;
      background: rgba(10, 15, 20, 0.8);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      padding: 1rem;
      border-radius: 8px;
      resize: vertical;
      min-height: 120px;
      line-height: 1.6;
      font-size: 0.95rem;
      transition: all 0.3s ease;
      backdrop-filter: blur(5px);
    }

    textarea::placeholder {
      color: var(--text-secondary);
      opacity: 0.7;
    }

    textarea:focus {
      outline: none;
      border-color: var(--primary-green);
      box-shadow: 0 0 0 3px rgba(0, 217, 95, 0.1), inset 0 0 10px rgba(0, 217, 95, 0.05);
      background: rgba(10, 15, 20, 0.95);
    }

    .button-group {
      display: flex;
      gap: 1rem;
      margin-top: 1.2rem;
      flex-wrap: wrap;
    }

    button {
      font-family: 'IBM Plex Mono', monospace;
      background: linear-gradient(135deg, var(--primary-green) 0%, #00ff7f 100%);
      color: #000;
      border: none;
      padding: 0.8rem 1.6rem;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      transition: all 0.3s cubic-bezier(0.23, 1, 0.320, 1);
      position: relative;
      overflow: hidden;
      box-shadow: 0 4px 12px rgba(0, 217, 95, 0.2);
    }

    button::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }

    button:hover:not(:disabled) {
      background: linear-gradient(135deg, #00ff7f 0%, var(--primary-green) 100%);
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(0, 217, 95, 0.4);
    }

    button:hover:not(:disabled)::before {
      width: 300px;
      height: 300px;
    }

    button:active:not(:disabled) {
      transform: translateY(0);
    }

    button:disabled {
      background: linear-gradient(135deg, #555 0%, #333 100%);
      color: #999;
      cursor: not-allowed;
      box-shadow: none;
      opacity: 0.5;
    }

    .feedback {
      margin-top: 1rem;
      padding: 1rem;
      border-radius: 8px;
      display: none;
      font-size: 0.9rem;
      animation: slideDown 0.4s ease-out;
    }

    .feedback.show {
      display: block;
    }

    .feedback.success {
      background: rgba(0, 217, 95, 0.1);
      border: 1px solid var(--accent-success);
      color: var(--accent-success);
      box-shadow: 0 0 10px rgba(0, 217, 95, 0.15);
    }

    .feedback.error {
      background: rgba(255, 71, 87, 0.1);
      border: 1px solid var(--accent-error);
      color: #ff6b7a;
      box-shadow: 0 0 10px rgba(255, 71, 87, 0.15);
    }

    .info-text {
      font-size: 0.85rem;
      color: var(--text-secondary);
      margin-top: 0.8rem;
      opacity: 0.85;
    }

    #preview {
      background: rgba(10, 15, 20, 0.8);
      border: 1px solid var(--border-color);
      padding: 1.5rem;
      border-radius: 8px;
      min-height: 150px;
      word-wrap: break-word;
      white-space: pre-wrap;
      overflow-x: auto;
      transition: all 0.3s ease;
    }

    #preview:hover {
      border-color: var(--primary-green);
      box-shadow: inset 0 0 10px rgba(0, 217, 95, 0.05);
    }

    #preview code {
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid var(--border-color);
      padding: 1.2rem;
      display: block;
      border-radius: 6px;
      color: var(--primary-green);
      font-family: 'IBM Plex Mono', monospace;
      line-height: 1.6;
      font-size: 0.9rem;
    }

    .empty-state {
      color: var(--text-secondary);
      opacity: 0.7;
      font-style: italic;
      text-align: center;
      padding: 2rem;
    }

    /* åŠ¨ç”»å®šä¹‰ */
    @keyframes fadeInDown {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes slideInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes pulse {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0.3;
      }
    }

    /* å“åº”å¼è®¾è®¡ */
    @media (max-width: 768px) {
      body {
        padding: 1rem;
      }

      h1 {
        font-size: 1.5rem;
      }

      .section {
        padding: 1.2rem;
        margin-bottom: 1.5rem;
      }

      textarea {
        min-height: 100px;
        font-size: 14px;
      }

      .button-group {
        flex-direction: column;
        gap: 0.8rem;
      }

      button {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>âš¡ Terminal â†’ Markdown</h1>
    <p class="subtitle">å°†ç»ˆç«¯è¾“å‡ºä¼˜é›…åœ°è½¬æ¢ä¸º Markdown æ ¼å¼ â€¢ ç”¨äº Obsidian å’Œå…¶ä»–ç¬”è®°åº”ç”¨</p>

    <!-- ç²˜è´´è¾“å…¥åŒº -->
    <div class="section">
      <div class="section-title">ğŸ“‹ ç²˜è´´ç»ˆç«¯è¾“å‡º</div>
      <textarea id="pasteArea" placeholder="åœ¨æ­¤ç²˜è´´æ‚¨çš„ç»ˆç«¯è¾“å‡º..."></textarea>
      <div class="info-text">æ”¯æŒçº¯æ–‡æœ¬ã€HTML å’Œ RTF æ ¼å¼ã€‚ANSI ä»£ç å°†è‡ªåŠ¨åˆ é™¤ã€‚</div>
      <div class="button-group">
        <button onclick="convertFromClipboard()">ğŸ“¥ ä»å‰ªè´´æ¿ç²˜è´´</button>
        <button onclick="clearPasteArea()">ğŸ—‘ï¸ æ¸…ç©º</button>
      </div>
      <div id="pasteFeeback" class="feedback"></div>
    </div>

    <!-- Markdown è¾“å‡ºåŒº -->
    <div class="section">
      <div class="section-title">ğŸ“ ç”Ÿæˆçš„ Markdown</div>
      <textarea id="markdownOutput" placeholder="æ‚¨çš„ Markdown å°†åœ¨æ­¤æ˜¾ç¤º..."></textarea>
      <div class="button-group">
        <button id="copyButton" onclick="copyMarkdown()" disabled>ğŸ“‹ å¤åˆ¶ Markdown</button>
        <button onclick="clearMarkdown()">ğŸ—‘ï¸ æ¸…ç©º</button>
      </div>
      <div id="markdownFeedback" class="feedback"></div>
    </div>

    <!-- é¢„è§ˆåŒº -->
    <div class="section">
      <div class="section-title">ğŸ‘ï¸ Markdown é¢„è§ˆ</div>
      <div id="preview" class="empty-state">
        <div>æš‚æ— å†…å®¹é¢„è§ˆã€‚è¯·åœ¨ä¸Šæ–¹ç²˜è´´ç»ˆç«¯è¾“å‡ºä»¥å¼€å§‹ä½¿ç”¨ã€‚</div>
      </div>
    </div>
  </div>

  <script>
    // Configuration
    const CONFIG = {
      ansiRegex: /\x1b\[[0-9;]*m/g,
      consecutiveBlankLineRegex: /\n\n\n+/g,
      maxConsecutiveBlankLines: '\n\n'
    };

    // Utility Functions
    function showFeedback(elementId, message, type = 'success') {
      const element = document.getElementById(elementId);
      element.textContent = message;
      element.className = `feedback show ${type}`;
      setTimeout(() => {
        element.classList.remove('show');
      }, 3000);
    }

    function stripAnsiCodes(text) {
      return text.replace(CONFIG.ansiRegex, '');
    }

    function normalizeBlankLines(text) {
      return text.replace(CONFIG.consecutiveBlankLineRegex, CONFIG.maxConsecutiveBlankLines);
    }

    function extractPlainTextFromHtml(html) {
      const div = document.createElement('div');
      div.innerHTML = html;
      let text = div.innerText || div.textContent || '';
      return text;
    }

    function convertTerminalToMarkdown(text) {
      if (!text || text.trim() === '') {
        return '';
      }

      // Step 1: Strip ANSI color codes
      let cleaned = stripAnsiCodes(text);

      // Step 2: Normalize blank lines (3+ becomes 2)
      cleaned = normalizeBlankLines(cleaned);

      // Step 3: Trim leading/trailing whitespace
      cleaned = cleaned.trim();

      // Step 4: Wrap in fenced code block
      const markdown = '```text\n' + cleaned + '\n```';

      return markdown;
    }

    function updatePreview(markdownText) {
      const previewElement = document.getElementById('preview');

      if (!markdownText || markdownText.trim() === '') {
        previewElement.innerHTML = '<div class="empty-state">No markdown to preview yet. Paste terminal output above to get started.</div>';
        return;
      }

      // Parse and render markdown (simplified)
      const html = renderMarkdown(markdownText);
      previewElement.innerHTML = html;
    }

    function renderMarkdown(markdownText) {
      // Very simple markdown renderer for our use case (mostly code blocks)
      let html = '';
      const lines = markdownText.split('\n');
      let inCodeBlock = false;
      let codeContent = [];

      for (let line of lines) {
        if (line.startsWith('```')) {
          if (!inCodeBlock) {
            inCodeBlock = true;
            codeContent = [];
          } else {
            inCodeBlock = false;
            const escapedCode = codeContent.join('\n').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            html += '<code>' + escapedCode + '</code>';
            codeContent = [];
          }
        } else if (inCodeBlock) {
          codeContent.push(line);
        }
      }

      return html || '<div class="empty-state">Preview unavailable</div>';
    }

    function enableCopyButton() {
      const markdownText = document.getElementById('markdownOutput').value;
      const copyButton = document.getElementById('copyButton');
      copyButton.disabled = !markdownText || markdownText.trim() === '';
    }

    // ä¸»è¦äº‹ä»¶å¤„ç†å‡½æ•°
    function convertFromClipboard() {
      navigator.clipboard.read().then(items => {
        if (items.length === 0) {
          showFeedback('pasteFeeback', 'âŒ å‰ªè´´æ¿ä¸­æ— å†…å®¹', 'error');
          return;
        }

        const item = items[0];
        let textPromise = null;

        // ä¼˜å…ˆçº§ï¼šRTF > HTML > çº¯æ–‡æœ¬
        if (item.types.includes('text/rtf')) {
          textPromise = item.getType('text/rtf').then(blob => blob.text());
        } else if (item.types.includes('text/html')) {
          textPromise = item.getType('text/html').then(blob => {
            return blob.text().then(html => extractPlainTextFromHtml(html));
          });
        } else if (item.types.includes('text/plain')) {
          textPromise = item.getType('text/plain').then(blob => blob.text());
        }

        if (!textPromise) {
          showFeedback('pasteFeeback', 'âŒ ä¸æ”¯æŒçš„å‰ªè´´æ¿æ ¼å¼', 'error');
          return;
        }

        textPromise.then(text => {
          document.getElementById('pasteArea').value = text;
          convertPaste();
          showFeedback('pasteFeeback', 'âœ“ ç²˜è´´æˆåŠŸ', 'success');
        }).catch(err => {
          showFeedback('pasteFeeback', 'âŒ è¯»å–å‰ªè´´æ¿å¤±è´¥ï¼š' + err.message, 'error');
        });
      }).catch(err => {
        // é™çº§æ–¹æ¡ˆï¼šå°è¯•æ ‡å‡† Clipboard API
        navigator.clipboard.readText().then(text => {
          document.getElementById('pasteArea').value = text;
          convertPaste();
          showFeedback('pasteFeeback', 'âœ“ ç²˜è´´æˆåŠŸ', 'success');
        }).catch(fallbackErr => {
          showFeedback('pasteFeeback', 'âŒ å‰ªè´´æ¿è®¿é—®è¢«æ‹’ç»ã€‚è¯·ä½¿ç”¨ Ctrl+V æ‰‹åŠ¨ç²˜è´´', 'error');
        });
      });
    }

    function convertPaste() {
      const pasteAreaText = document.getElementById('pasteArea').value;
      const markdown = convertTerminalToMarkdown(pasteAreaText);
      document.getElementById('markdownOutput').value = markdown;
      updatePreview(markdown);
      enableCopyButton();
    }

    function copyMarkdown() {
      const markdownText = document.getElementById('markdownOutput').value;

      if (!markdownText || markdownText.trim() === '') {
        showFeedback('markdownFeedback', 'âŒ æ— å†…å®¹å¯å¤åˆ¶', 'error');
        return;
      }

      navigator.clipboard.writeText(markdownText).then(() => {
        showFeedback('markdownFeedback', 'âœ“ Markdown å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
      }).catch(err => {
        // é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨æ—§æ–¹æ³•
        const textArea = document.getElementById('markdownOutput');
        textArea.select();
        document.execCommand('copy');
        showFeedback('markdownFeedback', 'âœ“ Markdown å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
      });
    }

    function clearPasteArea() {
      document.getElementById('pasteArea').value = '';
      showFeedback('pasteFeeback', 'âœ“ ç²˜è´´åŒºå·²æ¸…ç©º', 'success');
    }

    function clearMarkdown() {
      document.getElementById('markdownOutput').value = '';
      document.getElementById('preview').innerHTML = '<div class="empty-state">æš‚æ— å†…å®¹é¢„è§ˆã€‚è¯·åœ¨ä¸Šæ–¹ç²˜è´´ç»ˆç«¯è¾“å‡ºä»¥å¼€å§‹ä½¿ç”¨ã€‚</div>';
      enableCopyButton();
      showFeedback('markdownFeedback', 'âœ“ Markdown å·²æ¸…ç©º', 'success');
    }

    // äº‹ä»¶ç›‘å¬å™¨
    document.getElementById('pasteArea').addEventListener('input', () => {
      convertPaste();
    });

    document.getElementById('markdownOutput').addEventListener('input', () => {
      updatePreview(document.getElementById('markdownOutput').value);
      enableCopyButton();
    });

    // åˆå§‹åŒ–
    window.addEventListener('load', () => {
      enableCopyButton();
    });

    // å…è®¸ Ctrl+V ç²˜è´´
    document.getElementById('pasteArea').addEventListener('paste', (e) => {
      setTimeout(() => {
        convertPaste();
        showFeedback('pasteFeeback', 'âœ“ å†…å®¹ç²˜è´´å¹¶å·²è½¬æ¢', 'success');
      }, 0);
    });
  </script>
</body>
</html>
